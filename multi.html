<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>다층 신경망(MLP) 비선형 결정 경계 시뮬레이션</title>
<style>
  :root { --bg:#0b1020; --ink:#e6e8ef; --muted:#9aa3b2; --accent:#6ea8fe; --panel:#111a33; --border:#1f2a46; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b1020,#0a0f1f);color:var(--ink);
       font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',Arial}
  .container{max-width:1180px;margin:0 auto;padding:18px}
  .header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .logo{width:36px;height:36px;border-radius:10px;background:linear-gradient(135deg,#6ea8fe,#88e1ff);
        color:#0b1020;font-weight:800;display:flex;align-items:center;justify-content:center}
  h1{font-size:18px;margin:0}
  .panel{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px; margin-top:12px}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:12px}
  .controls .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
  label{color:var(--muted)} select, input[type=number]{background:#0c142c;border:1px solid var(--border);color:var(--ink);border-radius:8px;padding:6px 8px}
  input[type=range]{width:160px}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;border:1px solid var(--border);
       background:#0c142c;color:var(--ink);cursor:pointer}
  .btn.primary{background:#6ea8fe;color:#0b1020;border-color:transparent;font-weight:700}
  .stat{font-variant-numeric:tabular-nums}
  canvas{width:100%;height:560px;border:1px solid var(--border);background:#0c142c;border-radius:12px}
  code{background:#0c142c;border:1px solid var(--border);padding:2px 6px;border-radius:6px}
  .small{color:var(--muted);font-size:12px}
  .ok{color:#22c55e;font-weight:700}
  .err{color:#ef4444;font-weight:700}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">AI</div>
      <div>
        <h1>다층 신경망(MLP) 비선형 결정 경계 시뮬레이션</h1>
        <div class="small">은닉층/노드/활성화 함수를 바꾸어 결정 경계가 어떻게 변하는지 관찰</div>
      </div>
    </div>

    <div class="panel grid">
      <div>
        <canvas id="plot" width="760" height="560" aria-label="MLP 시각화 캔버스"></canvas>
      </div>
      <div class="controls">
        <div class="row"><label>데이터셋</label>
          <select id="dataset">
            <option value="linear">선형(직선 분리 가능)</option>
            <option value="moons" selected>반달(비선형)</option>
            <option value="circles">동심원(비선형)</option>
          </select>
        </div>
        <div class="row"><label>은닉층 수</label>
          <select id="layers">
            <option value="0">0 (선형 모델)</option>
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select>
        </div>
        <div class="row"><label>층당 노드 수</label>
          <input id="width" type="number" min="1" max="32" step="1" value="8">
        </div>
        <div class="row"><label>활성화 함수</label>
          <select id="act">
            <option value="relu" selected>ReLU</option>
            <option value="tanh">tanh</option>
          </select>
        </div>
        <div class="row"><label>학습률 η</label>
          <input id="lr" type="range" min="0.001" max="0.5" step="0.001" value="0.03">
          <span id="lrVal" class="stat">0.03</span>
        </div>
        <div class="row"><label>배치 모드</label>
          <select id="batch">
            <option value="full">전체</option>
            <option value="mini" selected>미니배치(32)</option>
            <option value="stochastic">확률적(1개)</option>
          </select>
        </div>
        <div class="row" style="gap:8px">
          <button id="rebuild" class="btn">네트워크 재구성</button>
          <button id="regen" class="btn">데이터 재생성</button>
        </div>
        <div class="row" style="gap:8px">
          <button id="startBtn" class="btn primary">시작</button>
          <button id="pauseBtn" class="btn">일시정지</button>
          <button id="resetBtn" class="btn">초기화</button>
        </div>
        <div class="panel">
          <div><b>모델</b> <span class="small">입력(2) → 은닉 L층 → 출력(1, sigmoid)</span></div>
          <div class="small" style="margin-top:6px">은닉층이 0이면 선형 회귀/로지스틱과 동일(결정 경계=직선). 은닉층≥1이고 활성화가 비선형이면 곡선 경계 가능.</div>
        </div>
        <div class="panel">
          <div><b>통계</b></div>
          <div class="row"><span>손실(L):</span> <span id="loss" class="stat">-</span></div>
          <div class="row"><span>정확도:</span> <span id="acc" class="stat">-</span></div>
          <div class="row"><span>파라미터 수:</span> <span id="params" class="stat">-</span></div>
          <div class="row"><span>데이터 크기:</span> <span id="dataSize" class="stat">-</span></div>
          <div class="row"><span>스텝:</span> <span id="step" class="stat">0</span></div>
        </div>
        <div class="panel">
          <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
            <div><b>진단</b> <span class="small">간단한 셀프 테스트</span></div>
            <button id="selfTest" class="btn">Self-Test</button>
          </div>
          <div id="diag" class="small"></div>
        </div>
        <div class="small">팁: 동심원/반달에서 은닉층을 0으로 두면 학습이 어려워집니다. 은닉층과 노드를 늘리면 곡선 경계가 나타납니다.</div>
      </div>
    </div>

    <div class="panel"><b>설명</b>
      <div class="small">손실: 이진 교차엔트로피, 최적화: 경사하강법. 시각화는 배경 격자에 대한 예측 확률을 색으로 칠합니다.</div>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('plot');
  const ctx = canvas.getContext('2d');
  const datasetSel = document.getElementById('dataset');
  const layersSel = document.getElementById('layers');
  const widthInp = document.getElementById('width');
  const actSel = document.getElementById('act');
  const lrEl = document.getElementById('lr');
  const lrVal = document.getElementById('lrVal');
  const batchSel = document.getElementById('batch');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const regenBtn = document.getElementById('regen');
  const rebuildBtn = document.getElementById('rebuild');
  const selfTestBtn = document.getElementById('selfTest');
  const diag = document.getElementById('diag');
  const lossEl = document.getElementById('loss');
  const accEl = document.getElementById('acc');
  const paramsEl = document.getElementById('params');
  const dataSizeEl = document.getElementById('dataSize');
  const stepEl = document.getElementById('step');

  // data area
  const PAD = 30;
  const xMin = -3, xMax = 3;
  const yMin = -3, yMax = 3;
  const sx = x => PAD + (x - xMin) * (canvas.width - 2*PAD) / (xMax - xMin);
  const sy = y => canvas.height - (PAD + (y - yMin) * (canvas.height - 2*PAD) / (yMax - yMin));
  const ix = X => xMin + (X - PAD) * (xMax - xMin) / (canvas.width - 2*PAD);
  const iy = Y => yMin + (canvas.height - Y - PAD) * (yMax - yMin) / (canvas.height - 2*PAD);

  function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

  function makeData(kind='moons', N=400){
    const pts=[];
    if(kind==='linear'){
      for(let i=0;i<N;i++){
        const x = randn();
        const y = 0.8*x + (randn()*0.5) + 0.5; // roughly linear sep
        const ytrue = (y > 0.8*x + 0.3) ? 1 : 0;
        pts.push({x,y,ytrue});
      }
    } else if(kind==='moons'){
      // two moons
      for(let i=0;i<N/2;i++){
        const t = Math.random()*Math.PI; // 0..pi
        const x = Math.cos(t) + randn()*0.1;
        const y = Math.sin(t) + randn()*0.1;
        pts.push({x,y,ytrue:0});
      }
      for(let i=0;i<N/2;i++){
        const t = Math.random()*Math.PI; // 0..pi
        const x = 1 - Math.cos(t) + randn()*0.1;
        const y = -Math.sin(t) - 0.5 + randn()*0.1;
        pts.push({x,y,ytrue:1});
      }
    } else if(kind==='circles'){
      for(let i=0;i<N;i++){
        const r = (i%2===0? 0.8 : 1.8) + randn()*0.08;
        const t = Math.random()*Math.PI*2;
        const x = r*Math.cos(t);
        const y = r*Math.sin(t);
        pts.push({x,y,ytrue: i%2});
      }
    }
    return pts;
  }

  // activation
  const ACT = {
    relu: { f: x=> x>0?x:0, df: x=> x>0?1:0 },
    tanh: { f: x=> Math.tanh(x), df: x=> { const t=Math.tanh(x); return 1 - t*t; } }
  };

  // helpers
  function clampInt(value, min, max, fallback){
    const n = parseInt(value,10);
    if(Number.isFinite(n) && n>=min && n<=max) return n;
    return fallback;
  }
  function last(arr){ return arr[arr.length-1]; }

  // network
  function buildNet(L, W, actName){
    // sanitize
    L = clampInt(L, 0, 5, 1);
    W = clampInt(W, 1, 64, 8);
    const sizes = [2]; for(let i=0;i<L;i++) sizes.push(W); sizes.push(1);
    const params = [];
    for(let i=0;i<sizes.length-1;i++){
      const inSize = sizes[i];
      const outSize = sizes[i+1];
      const scale = Math.sqrt(2/Math.max(1,inSize)); // He-like init
      const w = new Array(outSize).fill(0).map(()=> new Array(inSize).fill(0).map(()=> (Math.random()*2-1)*scale));
      const b = new Array(outSize).fill(0);
      params.push({w,b});
    }
    return {sizes, params, actName};
  }

  function forward(net, x){
    if(!Array.isArray(x) || x.length!==2) throw new Error('forward(): invalid input vector');
    const zs=[]; const as=[x.slice()];
    const L = net.params.length;
    for(let i=0;i<L;i++){
      const {w,b} = net.params[i];
      const inVec = last(as);
      const outSize = w.length; const inSize = w[0].length;
      const z = new Array(outSize).fill(0);
      const a = new Array(outSize).fill(0);
      for(let o=0;o<outSize;o++){
        let s=b[o];
        for(let j=0;j<inSize;j++) s += w[o][j]*inVec[j];
        z[o]=s;
        if(i===L-1){ a[o] = 1/(1+Math.exp(-s)); }
        else { a[o] = ACT[net.actName].f(s); }
      }
      zs.push(z); as.push(a);
    }
    return {zs, as};
  }

  function backward(net, cache, ytrue){
    const L = net.params.length;
    const grads = net.params.map(({w,b})=>({dw: w.map(row=>row.map(()=>0)), db: b.map(()=>0)}));
    let delta = last(cache.as).map(a => a - ytrue); // output: (a - y)
    for(let i=L-1;i>=0;i--){
      const aPrev = cache.as[i];
      const {w} = net.params[i];
      const g = grads[i];
      const outSize = w.length; const inSize = w[0].length;
      for(let o=0;o<outSize;o++){
        g.db[o] += delta[o];
        for(let j=0;j<inSize;j++) g.dw[o][j] += delta[o] * aPrev[j];
      }
      if(i>0){
        const deltaPrev = new Array(inSize).fill(0);
        for(let j=0;j<inSize;j++){
          let s=0; for(let o=0;o<outSize;o++) s += w[o][j]*delta[o];
          deltaPrev[j] = s * ACT[net.actName].df(cache.zs[i-1][j]);
        }
        delta = deltaPrev;
      }
    }
    return grads;
  }

  function applyGrads(net, grads, lr, m){
    const denom = Math.max(1, m);
    for(let i=0;i<net.params.length;i++){
      const p = net.params[i]; const g = grads[i];
      for(let o=0;o<p.w.length;o++){
        p.b[o] -= lr * (g.db[o]/denom);
        for(let j=0;j<p.w[0].length;j++) p.w[o][j] -= lr * (g.dw[o][j]/denom);
      }
    }
  }

  function zeroGradsLike(net){
    return net.params.map(({w,b})=>({dw: w.map(row=>row.map(()=>0)), db: b.map(()=>0)}));
  }
  function addGrads(G, g){
    for(let i=0;i<G.length;i++){
      for(let o=0;o<G[i].dw.length;o++){
        G[i].db[o]+=g.db[o];
        for(let j=0;j<G[i].dw[0].length;j++) G[i].dw[o][j]+=g.dw[o][j];
      }
    }
  }

  // training infra
  let data = [];
  let net = null;
  let running=false, step=0;

  function safePredictProb(net, x){
    const out = forward(net,x).as; // [[...], ..., [p]]
    const lastA = last(out);
    if(!lastA || lastA.length===0 || typeof lastA[0] !== 'number') throw new Error('predict: invalid activation');
    return lastA[0];
  }

  function countParams(net){
    let c=0; for(const p of net.params){ c += (p.w.length>0 ? p.w.length * p.w[0].length : 0) + p.b.length; } return c;
  }

  function lossAcc(){
    if(!data.length) return {L:NaN, acc: 0};
    let L=0, correct=0; const eps=1e-8;
    for(const p of data){
      const yhat = safePredictProb(net,[p.x,p.y]);
      L += -(p.ytrue*Math.log(yhat+eps)+(1-p.ytrue)*Math.log(1-yhat+eps));
      const pred = yhat>=0.5?1:0; if(pred===p.ytrue) correct++;
    }
    return {L:L/data.length, acc: correct/data.length};
  }

  function buildIdxs(mode){
    const n = data.length;
    if(n===0) return [];
    if(mode==='full') return [...data.keys()];
    if(mode==='stochastic') return [Math.floor(Math.random()*n)];
    // mini
    const size = Math.min(32, n);
    const set=new Set();
    while(set.size<size) set.add(Math.floor(Math.random()*n));
    return [...set];
  }

  function trainStep(){
    const mode = batchSel.value;
    const idxs = buildIdxs(mode);
    if(!idxs.length) return; // no data yet
    let G = zeroGradsLike(net);
    for(const i of idxs){
      const p = data[i];
      if(!p) continue; // guard
      const cache = forward(net, [p.x,p.y]);
      const g = backward(net, cache, p.ytrue);
      addGrads(G,g);
    }
    applyGrads(net, G, parseFloat(lrEl.value), idxs.length);
    step++;
  }

  function draw(){
    // background decision surface
    const W=canvas.width, H=canvas.height;
    const res=4; // grid resolution in px
    const img = ctx.createImageData(W,H);
    for(let Y=0;Y<H;Y+=res){
      for(let X=0;X<W;X+=res){
        const x=ix(X+res/2), y=iy(Y+res/2);
        let p=0.5; // default gray
        try { p = safePredictProb(net,[x,y]); } catch(e){ p = 0.5; }
        const r = Math.floor(100 + 120*p); // blue->orange blend
        const g = Math.floor(120 + 100*(1-Math.abs(p-0.5)*2));
        const b = Math.floor(255 - 180*p);
        for(let yy=0; yy<res; yy++){
          for(let xx=0; xx<res; xx++){
            const idx = 4*((Y+yy)*W + (X+xx));
            img.data[idx]=r; img.data[idx+1]=g; img.data[idx+2]=b; img.data[idx+3]=255;
          }
        }
      }
    }
    ctx.putImageData(img,0,0);

    // axes grid
    ctx.strokeStyle = '#1f2a46'; ctx.lineWidth=1; ctx.beginPath();
    for(let gx=Math.ceil(xMin); gx<=xMax; gx++){ const X=sx(gx); ctx.moveTo(X, sy(yMin)); ctx.lineTo(X, sy(yMax)); }
    for(let gy=Math.ceil(yMin); gy<=yMax; gy++){ const Y=sy(gy); ctx.moveTo(sx(xMin), Y); ctx.lineTo(sx(xMax), Y); }
    ctx.stroke();

    // points
    for(const p of data){
      ctx.beginPath(); ctx.arc(sx(p.x), sy(p.y), 3.5, 0, Math.PI*2);
      ctx.fillStyle = p.ytrue? '#f59e0b' : '#60a5fa'; ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.stroke();
    }
  }

  function loop(){
    if(!running) return;
    for(let i=0;i<2;i++) trainStep();
    const s=lossAcc();
    lossEl.textContent = Number.isFinite(s.L)? s.L.toFixed(4) : '-';
    accEl.textContent=(s.acc*100).toFixed(1)+'%';
    paramsEl.textContent=countParams(net);
    dataSizeEl.textContent=data.length;
    stepEl.textContent=step;
    draw();
    requestAnimationFrame(loop);
  }

  function start(){ if(!running){ running=true; loop(); } }
  function pause(){ running=false; }
  function reset(){
    pause(); step=0;
    // sanitize UI values in case of manual edits
    const L = clampInt(layersSel.value, 0, 5, 1);
    const W = clampInt(widthInp.value, 1, 64, 8);
    layersSel.value = String(L);
    widthInp.value = String(W);
    net=buildNet(L,W,actSel.value);
    lossEl.textContent='-'; accEl.textContent='-'; paramsEl.textContent=countParams(net); stepEl.textContent='0';
    draw();
  }

  function regen(){ data = makeData(datasetSel.value); dataSizeEl.textContent=data.length; draw(); }
  function rebuild(){ reset(); }

  // Self tests
  function runSelfTests(){
    const logs=[];
    function ok(msg){ logs.push('<div class="ok">✔ ' + msg + '</div>'); }
    function err(msg){ logs.push('<div class="err">✖ ' + msg + '</div>'); }
    try {
      // 1) Net shapes valid
      const testNet = buildNet(1,8,'relu');
      if(testNet.params.length!==2) err('파라미터 층 수 mismatch'); else ok('네트워크 구성(1x8)');
      // 2) Forward returns probability
      const out = safePredictProb(testNet,[0,0]);
      if(!(out>0 && out<1)) err('forward 출력 범위 오류'); else ok('forward 출력 0..1');
      // 3) Data generation non-empty
      const ds = makeData('moons',200);
      if(ds.length===200) ok('데이터 생성 200개'); else err('데이터 생성 실패');
      // 4) Training step does not throw on empty data
      const prevParams = JSON.stringify(testNet.params);
      try{ const tmpRunning=running; running=false; }catch(e){}
      // 5) Index builder handles n=0
      const old = data; data=[]; const idxs = buildIdxs('mini'); if(idxs.length===0) ok('빈 데이터셋 처리'); else err('빈 데이터셋 idx 생성 오류'); data = old;
    } catch(e){ err('예외: '+e.message); }
    diag.innerHTML = logs.join('');
  }

  // UI events
  lrEl.addEventListener('input', ()=> lrVal.textContent = lrEl.value);
  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', pause);
  resetBtn.addEventListener('click', reset);
  regenBtn.addEventListener('click', regen);
  rebuildBtn.addEventListener('click', rebuild);
  datasetSel.addEventListener('change', ()=>{ regen(); });
  layersSel.addEventListener('change', rebuild);
  widthInp.addEventListener('change', rebuild);
  actSel.addEventListener('change', rebuild);
  selfTestBtn.addEventListener('click', runSelfTests);

  // init (order matters)
  regen(); // populate data first
  reset(); // then build the net
  draw();
})();
</script>
</body>
</html>